<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>My Family </title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: Arial, sans-serif;
    background: #f9f9f9;
    overflow: hidden;
  }
  h2 {
    text-align:  center;
    margin: 10px 0;
    border-color: #28a745
  }
 
  .controls button {
  text-align: center;
  background-color: #28a745; /* nice green */
  color: white;
  border: none;
  border-radius: 8px; /* curvy corners */
  padding: 8px 16px;
  font-size: 14px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.controls button:hover {
  background-color: #218838; /* slightly darker green on hover */
}
  .tree-container {
    width: 100%;
    height: calc(100vh - 90px);
    overflow: hidden;
    border-top: 1px solid #ccc;
    background: white;
  }
  svg {
    font: 12px sans-serif;
    user-select: none;
    cursor: grab;
  }
  .node circle {
    fill: #4a90e2;
    stroke: #357ABD;
    stroke-width: 2px;
    cursor: pointer;
    transition: fill 0.3s;
  }
  .node circle.collapsed {
    fill: #fc0313;
  }
  .node text {
    font-size: 14px;
    fill: #333;
    cursor: pointer;
    user-select: none;
  }
  .link {
    fill: none;
    stroke: #aaa;
    stroke-opacity: 0.6;
    stroke-width: 2px;
  }
</style>
</head>
<body>
  <h2>My Family</h2>

  <div class="tree-container">
      <div class="controls">
    <button id="resetView">Reset View</button>
  </div>
    <svg></svg>
  </div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const container = d3.select(".tree-container");
const svg = d3.select("svg");

const zoom = d3.zoom()
  .scaleExtent([0.1, 3])
  .on("zoom", (event) => {
    g.attr("transform", event.transform);
  });
svg.call(zoom);

let g;
let rootHierarchy;

d3.csv("family_tree.csv").then(data => {
  const dataPairs = data.map(row => [
    { id: row.parent_id, name: row.parent_name },
    { id: row.child_id, name: row.child_name }
  ]);

  const nodes = new Map();

  for (const [parent, child] of dataPairs) {
    if (!nodes.has(parent.id)) {
      nodes.set(parent.id, { id: parent.id, name: parent.name, children: [] });
    }
    if (!nodes.has(child.id)) {
      nodes.set(child.id, { id: child.id, name: child.name, children: [] });
    }
    nodes.get(parent.id).children.push(nodes.get(child.id));
  }

  const childIds = new Set(dataPairs.map(([_, c]) => c.id));
  const root = [...nodes.values()].find(n => !childIds.has(n.id));

  rootHierarchy = d3.hierarchy(root);

  update(rootHierarchy);
});

function toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else if (d._children) {
    d.children = d._children;
    d._children = null;
  }
  update(d);
}

function update(source) {
  const nodeHeight = 70;
  const nodeWidth = 140;
  const margin = 50;

  const treeLayout = d3.tree().nodeSize([nodeHeight, nodeWidth]);
  treeLayout(rootHierarchy);

  const nodesArray = rootHierarchy.descendants();

  const xVals = nodesArray.map(d => d.x);
  const yVals = nodesArray.map(d => d.y);
  const minX = Math.min(...xVals);
  const maxX = Math.max(...xVals);
  const minY = Math.min(...yVals);
  const maxY = Math.max(...yVals);

  const containerNode = container.node();
  const viewportWidth = containerNode.clientWidth;
  const viewportHeight = containerNode.clientHeight;

  svg
    .attr("width", viewportWidth)
    .attr("height", viewportHeight);

  svg.selectAll("*").remove();

  g = svg.append("g");

  g.selectAll(".link")
    .data(rootHierarchy.links())
    .join("path")
    .attr("class", "link")
    .attr("d", d3.linkVertical()
      .x(d => d.x)
      .y(d => d.y)
    );

  const nodes = g.selectAll(".node")
    .data(nodesArray)
    .join("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${d.x},${d.y})`)
    .on("click", (event, d) => toggle(d));

  nodes.append("circle")
    .attr("r", 10)
    .attr("class", d => d.children ? "" : d._children ? "collapsed" : "");

  nodes.append("text")
    .attr("dy", "0.35em")
    .attr("y", 30)
    .attr("text-anchor", "middle")
    .text(d => d.data.name);

  fitToScreen();
}

function fitToScreen() {
  const margin = 50;
  const svgWidth = +svg.attr("width");
  const svgHeight = +svg.attr("height");

  const gBBox = g.node().getBBox();

  const scale = Math.min(
    svgWidth / (gBBox.width + margin * 2),
    svgHeight / (gBBox.height + margin * 2)
  );

  const translateX = (svgWidth - gBBox.width * scale) / 2 - gBBox.x * scale;
  const translateY = (svgHeight - gBBox.height * scale) / 2 - gBBox.y * scale;

  svg.transition().duration(750).call(
    zoom.transform,
    d3.zoomIdentity.translate(translateX, translateY).scale(scale)
  );
}

d3.select("#resetView").on("click", fitToScreen);
</script>
</body>
</html>
